
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>GPX visualiser</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    #map { height: 90vh; width: 100%; }
    #controls { padding: 10px; }
    /* speed-legend (Leaflet control) */
    .speed-legend{
      background:rgba(255,255,255,0.85);
      padding:6px 8px;
      font:12px/14px Arial,sans-serif;
      box-shadow:0 0 15px rgba(0,0,0,0.2);
      border-radius:5px;
    }
    .speed-legend i{
      width:12px;height:12px;
      float:left;margin-right:6px;
      opacity:.7;
    }
  </style>
</head>
<body>
  <div id="controls">
    <p>Upload a .gpx export from komoot. Input intended days. Get theorical time-based end-of-day location</p>
    <input type="file" id="gpxFile" accept=".gpx" />
    <input type="number" id="daysCount" placeholder="#days" />
    <button id="daysBtn">Render days</button>
    <button id="exportBtn" disabled>Export markers as GPX</button>
  </div>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    /* ––––– helpers ––––– */
    const R = 6371000;
    const toRad = d => d * Math.PI / 180;
    const haversine = (la1, lo1, la2, lo2) => {
      const dLat = toRad(la2 - la1), dLon = toRad(lo2 - lo1);
      const a = Math.sin(dLat/2)**2 +
                Math.cos(toRad(la1))*Math.cos(toRad(la2))*Math.sin(dLon/2)**2;
      return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    };
    const colours = ['purple','blue','green','yellow','orange','red'];
    const colourForSpeed = (v,min,max) =>
      colours[Math.min(colours.length-1,
        Math.floor(((v-min)/(max-min+1e-9))*colours.length))];

    let lastMarkers = [];          // will hold {lat, lon, name} for the current run
    let speedLegend = null;      // Leaflet control instance (one per track)

    function downloadAsGPX(pts){
      const gpx =
`<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="GPX visualiser">
${pts.map(p=>`  <wpt lat="${p.lat}" lon="${p.lon}"><name>${p.name}</name></wpt>`).join('\n')}
</gpx>`;
      const blob = new Blob([gpx], {type:'application/gpx+xml'});
      const a = Object.assign(document.createElement('a'), {
        href: URL.createObjectURL(blob),
        download: 'markers.gpx'
      });
      a.click(); URL.revokeObjectURL(a.href);
    }

    function updateLegend(min, max){
      if (speedLegend) map.removeControl(speedLegend);   // wipe previous one
      const steps = colours.length, step = (max-min||1)/steps;

      speedLegend = L.control({position:'bottomright'});
      speedLegend.onAdd = function(){
        const div = L.DomUtil.create('div','speed-legend');
        for(let i=0;i<steps;i++){
          const a = (min + i*step).toFixed(1),
                b = (min + (i+1)*step).toFixed(1);
          div.innerHTML += `<i style="background:${colours[i]}"></i>${a}–${b} m/s<br>`;
        }
        return div;
      };
      speedLegend.addTo(map);
    }

    /* ––––– map ––––– */
    const map = L.map('map').setView([0,0],2);
    const drawn = L.layerGroup().addTo(map);   /* holds the track currently shown */
    L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',{
      attribution:'© OpenStreetMap, SRTM | OpenTopoMap (CC-BY-SA)'
    }).addTo(map);

    /* ––––– UI ––––– */

    /* render buckets by “days” -------------------------------------------- */
    document.getElementById('daysBtn').addEventListener('click', () => {
      const file = document.getElementById('gpxFile').files[0];
      if (!file) { alert('Choose a GPX file'); return; }
      const v      = document.getElementById('daysCount').value.trim();
      const daysN  = v ? parseFloat(v) : NaN;          // may still be NaN
      const reader = new FileReader();
      reader.onload = e => renderMap(e.target.result, 'days', daysN);
      reader.readAsText(file);
    });

    document.getElementById('exportBtn')
            .addEventListener('click', () => downloadAsGPX(lastMarkers));

    /* ––––– GPX → map ––––– */
    function renderMap(gpxText, mode, daysN){
      lastMarkers = [];
      document.getElementById('exportBtn').disabled = true;
      drawn.clearLayers();                    // wipe previous track & markers
      const pts = Array.from(new DOMParser()
        .parseFromString(gpxText,'application/xml')
        .getElementsByTagName('trkpt'))
        .map(p => ({
          lat:+p.getAttribute('lat'),
          lon:+p.getAttribute('lon'),
          time:new Date(p.getElementsByTagName('time')[0]?.textContent)
        }));
      if (pts.length<2){alert('Not enough points');return;}

      drawDays(pts, daysN);    // show only the requested days

      if (lastMarkers.length)
        document.getElementById('exportBtn').disabled = false;

      if (drawn.getLayers().length) {
        map.fitBounds(drawn.getBounds());
      }
    }


    function drawDays(pts, daysN){
      const base = pts[0].time;                       // ride start-time (ms)

      /* decide which time-bucketing logic to use — partial first day then equal slices */
      let bucketOf;                                            // maps time → bucket #
      if (Number.isFinite(daysN) && daysN > 0) {
        const totalDuration = pts[pts.length-1].time - base;   // full ride span (ms)
        const slice = totalDuration / daysN;                   // “x” in the description
        const intDays = Math.floor(daysN);                     // number of whole days
        const frac    = daysN - intDays;                       // 0 ≤ frac < 1

        if (frac === 0) {                                      // no partial day
          /* keep the last sample inside the last bucket       */
          bucketOf = t => {
            const idx = Math.floor((t - base) / slice);
            return Math.min(daysN - 1, idx);      // clamp
          };
        } else {                                               // partial first bucket
          const firstLen = frac * slice;                       // ms length of bucket 0
          bucketOf = t => {
            const dt  = t - base;
            if (dt < firstLen) return 0;
            const idx = 1 + Math.floor((dt - firstLen) / slice);
            return Math.min(intDays, idx);      // clamp
          };
        }
      } else {                                                 // invalid / empty input
        bucketOf = _ => 0;
      }

      // Compute segment speeds and their limits
      const speeds = pts.slice(1).map((p,i)=>
        haversine(pts[i].lat, pts[i].lon, p.lat, p.lon) /
        (((p.time - pts[i].time) / 1000) || 1)         // m / s
      );
      const [min, max] = [Math.min(...speeds), Math.max(...speeds)];
      updateLegend(min, max);

      /* draw the coloured track + add a marker at the end of each bucket
         whose popup shows the distance (km) covered inside that bucket   */
      let currentBucket = bucketOf(pts[0].time);   // bucket we are filling
      let bucketDist    = 0;                       // metres accumulated in it
      let bucketTime    = 0;                       // ms accumulated in it

      for (let i = 1; i < pts.length; i++) {
        const prev = pts[i-1], curr = pts[i];
        const b = bucketOf(curr.time);

        /* if we are entering a new bucket, close the old one with a marker */
        if (b !== currentBucket) {
          const name = (bucketDist/1000).toFixed(1) + ' km, ' +
                       (bucketTime/3_600_000).toFixed(1) + ' h';
          L.marker([prev.lat, prev.lon]).addTo(drawn).bindPopup(name);
          lastMarkers.push({lat: prev.lat, lon: prev.lon, name});
          currentBucket = b;
          bucketDist = 0;
          bucketTime = 0;
        }

        const segDist = haversine(prev.lat, prev.lon, curr.lat, curr.lon);
        bucketDist += segDist;
        bucketTime += (curr.time - prev.time);

        L.polyline(
          [[prev.lat, prev.lon], [curr.lat, curr.lon]],
          { color: colourForSpeed(speeds[i - 1], min, max), weight: 4 }
        ).addTo(drawn);
      }

      /* drop the final bucket’s marker */
      if (bucketDist) {
        const last = pts[pts.length - 1];
        const name = (bucketDist/1000).toFixed(1) + ' km, ' +
                     (bucketTime/3_600_000).toFixed(1) + ' h';
        L.marker([last.lat, last.lon]).addTo(drawn).bindPopup(name);
        lastMarkers.push({lat: last.lat, lon: last.lon, name});
      }
    }
  </script>
</body>
</html>
